package 旋转图像;

/**
 * 1.这是一道观察规律然后进行推算的数学题
 * 2.从最简单的n=2开始找规律,可以发现第i行的第j列旋转之后会变成第j行的倒数第i列,可以表示为m[j][n-1-i]=m[i][j]
 * 3.然后令i'=j,j'=n-1-i,继续推算出m[n-1-i][n-1-j]=m[j][n-1-i]
 * 4.最后可以得出旋转之后这四个点会相互交换位置: m[i][j] -> m[j][n-1-i] -> m[n-1-i][n-1-j] -> m[n-1-j][i] -> m[i][j]
 *   所以每次遍历都是去交换这四个点的位置.
 * 5.然后剩下的问题是如何确定遍历的范围,这点官方题解的解释不详细,我觉得是要证明一下的.
 *   因为每次遍历都是操作4个点,显然我们只需遍历n*n/4个格子即可.
 *   直觉上n*n/4可以等于 (n/2) * (n/2) (即0 <= i < n/2 ,0 <= j < (n/2)),
 *   但也可以等于n * (n/4),究竟是哪种呢?
 *   从最简单的n=2开始观察,可以看到四个格子旋转后都是替换下一个格子,这个可以用上面的公式证明.
 *   然后令n=2k,也就是将每个格子细分,它们的行为并没有发生变化,依旧是大格子去替换顺时针的下一个格子,所以遍历的范围就是原先占1/4面积的大格子了,
 *   即0 <= i < n/2 ,0 <= j < (n/2)
 *   上面是n为偶数的情况,但n为奇数时格子并不能四等分,不适用上述方法.
 *   还是从最简单的n=3开始观察,可以看到多出来的一个格子是正中间的格子,它旋转之后并不会改变位置,所以不需要遍历它.
 *   其余8个格子,四等分为两个相邻的格子,然后旋转,还是可以看到四个格子旋转后替换了下一个格子,从而可以得出0 <= i < n/2 ,0 <= j < ( n+1 /2)
 *   综上,不管n是奇数还是偶数,遍历的范围都可以表示为0 <= i < n/2 ,0 <= j < ( n+1 /2)
 */
public class Solution {
    public void rotate(int[][] matrix) {
        int n=matrix.length;
        for (int i = 0; i < n/2 ; i++) {
            for (int j = 0; j <(n+1)/2 ; j++) {
                int tmp=matrix[i][j];
                matrix[i][j]=matrix[n-1-j][i];
                matrix[n-1-j][i]=matrix[n-1-i][n-1-j];
                matrix[n-1-i][n-1-j]=matrix[j][n-1-i];
                matrix[j][n-1-i]=tmp;
            }
        }
    }
}
