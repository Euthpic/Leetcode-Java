package 猜数字大小2;

/**
 * 记忆化搜索:通常用于穷举的情况,其中一些步骤的解后续步骤可以用得上,所以每一步求解的结果都缓存下来,便于复用
 * 评论区很多人反映看不懂"保证获胜的最小金额"是什么意思,其实可以概括为"局部取最大,整体取最小"
 * 我们可以决定的是猜哪个数x,每个x都对应一个金额,所以我们取其中的最小(整体取最小)
 * 但是我们不能保证的是能否猜中,以及猜错之后是继续往小猜还是往大猜,所以为了保证获胜,这里要按最差情况处理,即猜错并往金额较大的方向猜
 * 具体的实现关键是int cur = Math.max(dfs(l, x - 1), dfs(x + 1, r)) + x;
 * cur表示选择猜x之后的最大花费金额,这里隐含的一个判断是x已经猜错,所以继续猜的左右区间都不包含x
 *
 * 另一个可能较多人会迷惑的问题是:如果要猜的正确数字不在这个区间,那我要怎么获取这个区间的最大金额呢?
 * 其实当我们递归进这个区间时,就隐含了一个前提:正确的数字在这个区间.如果数字不在这个区间,我们是不用计算这个区间的.
 * 比如区间[1,5],我们猜了3,但是正确数字是4,接下来我们要算区间[4,5]的金额,但是不用算区间[1,2]的金额;假如正确数字是1或2,我们才用计算[1,2]的金额
 * 也就是当我们要计算这个区间的金额时,已经假设了正确数字在这个区间里.
 */
public class Solution {
    static int N = 210;
    static int[][] cache = new int[N][N];

    public int getMoneyAmount(int n) {
        return dfs(1, n);
    }

    private int dfs(int l, int r) {
        if (l >= r) return 0;
        if (cache[l][r] != 0) return cache[l][r];
        //一个magic number,作用等同于Math.max(),但能防止溢出
        int ans = 0x3f3f3f3f;
        for (int x = l; x <= r; x++) {
            // 局部取最大
            // x就是我们选择要猜的数.要么猜中要么猜错.猜中不用付钱,但是我们无法保证肯定猜中,所以要按猜错处理.
            // 猜错之后往小猜或往大猜,由于无法提前判断是偏大还是偏小,所以取两者间的大值.
            int cur = Math.max(dfs(l, x - 1), dfs(x + 1, r)) + x;
            // 整体取最小
            // 在这个区间选择猜每个数都有一个金额,取这里的最小金额
            ans = Math.min(cur, ans);
        }
        cache[l][r] = ans;
        return ans;
    }
}
